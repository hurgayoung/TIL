# 자료구조 이해

## 스택의 개념과 특성

### 스택이란

물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조

대표적인 선형 자료구조 중 하나. 스택에 자료를 삽입하거나, 스택에서 자료를 꺼낼 수 있음.

- 선형은 배열/리스트처럼 자료 간의 관계가 1:1의 관계
- 비선형은 트리/그래프처럼 자료 간의 관계가 1:N의 관계

### 후입선출 (LIFO)

가장 마지막에 넣은 자료가 가장 먼저 나오는 것

## 스택의 기본 연산

- **배열**을 사용해 구현할 수 있음 → 파이썬에서는 리스트를 사용해 구현할 수 있음
- 저장소 자체를 스택이라 부르기도 함
- **스택 포인터(top)**는 스택에서 마지막 삽입된 원소의 위치로, 데이터를 넣거나 뺄 때 기준이 되는 위치임

- 삽입 (Push) → 저장소에 자료를 저장하는 연산
- 삭제 (Pop) → 저장소에서 삽입한 자료를 역순으로 꺼내는 연산
- 스택이 공백인지 아닌지 확인하는 연산 (isEmpty) → 스택이 비어 있으면 True, 아니면 False 반환
- 스택의 top에 있는 item(원소)을 반환하는 연산(peek) → 삭제는 하지 않음



## 실습

### Push 연산

- append 메소드를 통해 리스트의 마지막에 데이터를 삽입

```python
def my_push(item):
		s.append(item)
```

- 인덱스 연산을 활용한 구현

```python
def my push(item, size):
		global top
		top += 1
		if top == size:
				print('overflow!')
		else:
				stack[top] = item
```

### 단순한 Push 연산

- 크기가 정해진 리스트와 인덱스 연산을 활용

```python
size = 10
stack = [0] * size
top = -1

push(10, size)
top += 1           # top을 하나 증가시키고
stack[top] = 20    # 자리에 20을 넣을게
```

### Pop 연산

- 남은 데이터 중 가장 늦게 저장된 데이터를 삭제

```python
def my_pop():
		if len(s) == 0:
				# underflow
				return
		else:
				return s.pop()
```

### 인덱스 연산을 이용한 Pop 연산

- 크기가 정해진 리스트와 인덱스 활용

```python
def my_pop():
		global top
		if top == -1:
				print('underflow')
				return 0
		else:
				top -= 1
				return stack[top+1]
	
	print(pop())
```

```python
# 간소화 버전
if top > -1:
		top -= 1
		print(stack[top+1])
```

### 스택 구현 고려 사항

- 1차원 배열을 사용하여 구현할 경우
    - 장점: 구현이 용이함
    - 단점: 스택의 크기 변경 어려움
- 해결 방법: 저장소를 동적으로 할당하여 스택을 구현하는 방법(동적 연결리스트 이용)
    - 장점: 메모리 효율적 사용 가능함
    - 단점: 구현이 복잡함

```python
stack = []
stack.append(1)
stack.append(2)
stack.append(3)

print(stack.pop())  # 3
print(stack.pop())  # 2
print(stack.pop())  # 1

top = -1
stack = [1] * 10

top += 1
stack[top] = 1
print(stack{[to[+1])
top -= 2
print(stack{[to[+1])
top -= 3
print(stack[top+1])
print(stack)

```

# 스택의 응용

## 괄호 검사


💡  if( (i==0) && (j==0) )



1. 문자열에 있는 괄호를 차례대로 검사하면서 왼쪽 괄호를 만나면 스택에 삽입하고, 오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지를 검사한다.
2. 이때, 스택이 비어 있으면 조건 1 또는 조건 2에 위배되고 괄호의 짝이 맞지 않으면 조건 3에 위배된다.
3. 마지막 괄호까지 조사한 후에도 스택에 괄호가 남아 있으면 조건 1에 위배된다.

**조건 1** – **왼쪽 괄호 없이 오른쪽 괄호가 나온 경우**

- 예: `")("`, `"())"`, `"([)]"`
- 아직 스택에 쌓인 왼쪽 괄호가 없는데 오른쪽 괄호를 만나면 잘못된 상태.
- 스택이 비어 있는 상태에서 `)`·`]`·`}` 같은 걸 만나면 바로 위배.

**조건 2** – **스택이 비어 있는 경우 오른쪽 괄호가 나온 경우**

- 사실 조건 1과 거의 같은 맥락인데, 여기서는 "검사 도중 스택이 비었는데 닫는 괄호를 만난" 상황을 별도로 명시.
- 즉, 열린 괄호보다 닫는 괄호가 먼저 나온 상황.

**조건 3** – **괄호의 종류가 맞지 않는 경우**

- 예: `"(]"`, `"[)"`, `"{)"`
- 스택 top이 `(`인데 닫는 괄호가 `]` 또는 `}`이면 짝이 틀린 것.
- 괄호 종류 매칭 규칙을 어김.

**마지막 검사** – **스택에 괄호가 남아 있는 경우**

- 모든 문자를 확인한 뒤에도 스택에 무언가 남아 있다면,
    
    → 열린 괄호가 닫히지 않은 상태 = 조건 1 위배 (열린 괄호만 있고 짝이 없음).
    
- 예: `"((("`, `"([{"`

---

📌 정리하면:

1. **조건 1**: 닫는 괄호가 나왔는데 매칭할 열린 괄호가 없음 (스택 비어 있음).
2. **조건 2**: 열린 괄호 없이 닫는 괄호가 먼저 나옴 (조건 1과 유사하지만 과정 중 상황을 강조).
3. **조건 3**: 괄호 종류가 맞지 않음.
4. 마지막 검사: 모든 검사 끝났는데 스택이 비어있지 않음 (조건 1의 변형).


# Function Call


- 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조.
- 즉, “후입선출” 구조의 스택을 이용하여 수행순서 관리