# [0820] 알고리즘 10일차 - Queue1(1)


# 큐 Queue

먼저 들어온 데이터가 먼저 나가는 선형 자료구조

스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조로 큐의 뒤에서는 삽입만 하고, 앞에서는 삭제만 이루어지는 구조입니다

### 선입선출 (FIFO, First In First Out)

가장 먼저 넣은 자료가 가장 먼저 나오는 것. 큐의 또다른 예시로 서비스 대기행렬이 있음.

큐에 1, 2, 3을 차례대로 넣으면 꺼내도 1, 2, 3이 순서대로 나옴.

*후입선출인 스택과 비교해서 알아두기


### 큐의 기본 연산

삽입 enqueue/삭제 dequeue

- enqueue(item) : 큐의 뒤쪽에 원소를 삽입하는 연산

- dequeue() : 큐의 앞쪽에서 원소를 삭제하고 반환하는 연산

- create_queue() : 공백 상태의 큐를 생성하는 연산

- is_empty() : 큐가 공백 상태인지를 확인하는 연산

- is_full() : 큐가 포화상태인지를 확인하는 연산

- qpeek() : 큐의 앞쪽에서 원소를 삭제 없이 반환하는 연산

## 선형 큐 Linear Queue

데이터를 일렬로 저장하며, 앞에서 꺼내고 뒤에 넣는 기본 큐 구조

- 구현
    - 배열이나 연결형 리스트로 구현할 수 있습니다
    - 큐의 크기 = 배열의 크기
    - front: 가장 최근에 삭제된 원소의 인덱스
    - rear: 마지막으로 저장된 원소의 인덱스
- 상태 표현
    - 초기 상태: front == rear = -1
    - 공백 상태: front == rear
    - 포화 상태: rear == n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)
- 문제점
    - 원소 삽입/삭제를 계속할 경우, 배열의 앞부분에 활용 공간을 포화상태로 인식하여 삽입 수행 불가

```python
# 초기 공백 큐 생성: create_queue()
# 크기 n인 1차원 배열 생성
# front와 rear를 -1로 초기화

q = [0] * n
front = -1
rear = -1
```

```python
# 삽입: enqueue(item)
# 마지막 원소 뒤에 새로운 원소 삽입을 위해 rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 지정
# 그 인덱스에 해당하는 배열원소 Q[rear]에 item을 저장

enqueue(item):
				global rear
				if is_full(): print("Queue_Full")
				else:
								rear <- rear + 1;
								q[rear[ <- item;
```

```python
# 삭제: dequeue()
# 가장 앞에 있는 원소를 삭제하기 위해 front 값을 하나 증가시켜 큐에 남아있는 첫 번째 원소 이동
# 새로운 첫 번째 원소를 리턴함으로써 삭제와 동일하게 기능함

dequeue()
				if(is_empty()) then queue_empty();
				else
								front <- front + 1;
								return Q[front];
```

```python
# 공백/포화상태 검사: is_empty(), is_full()
# 공백상태: front == rear
# 포화상태: rear == n-1(n: 배열의 크기, n-1: 배열의 마지막 인덱스)

is_empty():
				return front == rear
				
is_full():
				return rear == len(q) - 1
```

```python
# 큐에 원소 넣었다 빼기

front = rear = -1
q = [0] * 10

rear += 1    # enq(1)
q[rear] = 1
rear += 1    # enq(2)
q[rear] = 2
rear += 1    # enq(3)
q[rear] = 3

front += 1   # deq()
print(q[front])
front += 1   # deq()
print(q[front])
front += 1   # deq()
print(q[front])
```

## 원형 큐 Circular Queue

선형 큐의 공간 낭비를 막기 위해 처음과 끝이 연결된 구조

- 초기 공백 상태
    - front = rear = 0
- Index 순환
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킴
    - 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
    - 이를 위해 나머지 연산자 mod를 사용
- front 변수
    - 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리를 사용하지 않고 항상 “빈자리”로 둡니다.



```python
# 초기 공백 큐 생성: create_queue()
# 크기 n인 1차원 배열 생성
# front와 rear를 0으로 초기화

cq = [0] * n
front = rear = 0
```

```python
# 삽입: enqueue(item)
# 마지막 원소 뒤에 새로운 원소 삽입을 위해 rear 값을 조정하여 새로운 원소를 삽입할 자리를 지정
# 그 인덱스에 해당하는 배열원소 cQ[rear]에 item을 저장

def enqueue(item): 
		global rear
		if is_full():
				print("Queue_Full")
		else:
				rear = (rear + 1) % len(cq)
				cq[rear] = item
```

```python
# 삭제: dequeue()
# 가장 앞에 있는 원소를 삭제하기 위해 front 값을 조정하여 삭제할 자리를 지
# 새로운 front 원소를 리턴함으로써 삭제와 동일하게 기능함

def dequeue():
		global front
		if is_empty():
					print("Queue_Empty")
		else:
					front = (front + 1) % len(cq)
					return cq[front]
```

```python
# 공백/포화상태 검사: is_empty(), is_full()
# 공백상태: front == rear
# 포화상태: 삽입할 rear의 다음 위치 == 현재 front

is_empty():
				return front == rear
				
is_full():
				return (rear + 1) % len(cq) == front
```

## 연결 큐 Linked Queue

연결 리스트를 이용해 구현한 큐

- 단순 연결 리스트를 이용한 큐
    - 큐의 원소: 단순 연결 리스트의 노드
    - 큐의 원소 순서: 노드의 연결 순서. 링크로 연결되어 있ㅇ므
    - front: 첫 번째 노드를 가리키는 링크
    - rear: 마지막 노드를 가리키는 링크
- 상태 표현
    - 초기 상태: front = rear = null
    - 공백 상태: front = rear= null

### deque(덱)

- 컨테이너 자료형 중 하나로 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너
- append(x): 오른쪽에 x 추가
- popleft(): 왼쪽에서 요소를 제거하고 반환. 요소가 없으면 IndexError

```python
from collections import deque

q = deque()
q.append(1)       # enqueue()
t = q.popleft()   # dequeue()
```

## 우선순위 큐 Priority Queue

우선순위를 가진 항목들을 저장하는 큐

FIFO 순서가 아니라 우선순위가 높은 순서대로!

우선순위 큐의 적용 분야로 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 테스크 스케줄링 등에 쓰임

### 버퍼

데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역

버퍼를 채우는 것을 버퍼링이라고 함 !! 😮

순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 이용됨