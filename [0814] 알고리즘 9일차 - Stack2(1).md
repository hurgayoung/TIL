# [0814] 알고리즘 9일차 - Stack2(1)

```python
# 방은 1번부터 N번까지 있음
# 왼쪽 포털, 오른쪽 포털
# 오른쪽은 무조건 바로 옆 한 칸만 갈 수 있는 포털
# 왼쪽 포털은 주어진 번호로 바로 이동 하는 것
# 처음 그 방에 갔다면 => 무조건 왼쪽 포털 사용
#            두번째에 => 오른쪽 한 칸 간다  

# 1. 정확한 반복 횟수가 안나와 있고, 반복의 조건만 나와있다 => while
# 2. 방문처리(visited)
#

N = 5 # 방의 개수 5, 1번 ~ 5번 방까지 있음
P = [0] + [0, 1, 1, 2, 0] # N+1 크기의 배열을 만들고 가장 첫번째는 쓰지 않는다.
visited = [False] * (N+1)

idx = 1 # 1번방부터 시작
visited[idx] = True # 1번은 이미 방문한 상태로 시작, 2~N번방은 아직 방문하지 않은 상태
cnt = 0 # 포털 이용 횟수

# 목표: idx => N까지 가길 바람 (종료조건)
# <=> 반대되는 상황: idx가 아직 N이 아닌 상황 (반복해야 하는 조건)
while idx < N:
    idx += 1 # 오른쪽으로 한 칸 간다
    cnt += 1 # 한번 이동했으니까 카운트 늘리기
    print(idx, cnt) # 오른쪽으로 잘 이동하는지 체크

    if idx == N: # N번 방에 도달했다면 바로 while문 종료
        break # N번 방(마지막 방의 경우에는 왼쪽 포털 이동 기회를 차단)

    if not visited[idx]: # idx번 방을 처음 방문했다면
        visited[idx] = True
        idx = P[idx] # 왼쪽으로 이동
        cnt += 1 # 이동했으므로 카운트 늘려주기

print(cnt)
```

### 백트래킹

- 가지치기
- 굳이 탐색할 필요가 없다면 탐색하지 않는 것
- ex) n-queen

### 순열, 부분집합

- 재귀함수로 구현하기
- A형의 기본: 완전탐색
    - 순열, 부분집합, 조합, ….

### 재귀함수로 순열 만들기

```python
# 순열
# N개의 원소 중에서 R개를 뽑아서 순서 있게 나열하는 것

arr = [1, 2, 3, 4, 5]
N = len(arr)
R = 3

visited = [False] * N # 해당 숫자가 사용되었는지 여부 저장
res = [0] * 3 # 출력 배열(뽑은 숫자를 순서대로 저장할 배열)

# 재귀함수의 설계
# - R개를 뽑아야 한다면, R개를 한번에 뽑는 것이 아니라,
#   1개만 뽑고, 나머지 R-1개는 그 다음 재귀호출에 넘긴다.
# - 한번에 하나만 처리하고, 나머지는 그다음 재귀 호출에서 처리
# - ex) 0번 위치 하나만 뽑고, 나머지(1, 2, .., R-1)는 그다음 재귀 함수가 처리
# - ex) 1번 위치 하나만 뽑고, 나머지(2, 3, .., R-1)는 그 다음 재귀함수가 처리
# - ...
# - ex) n번 위치 하나를 뽑았다면, 나머지는(n+1 ~, R-1) 그 다음 재귀 함수가 처리 

# 재귀함수
# - 구조: 두 가지 파트로 나뉨
# - 1. 기저조건(base case): 재귀함수가 끝나는 조건, 더이상 자기자신을 호출하지 않는 조건
# - 2. 유도조건: 자기자신을 호출하는 경우

def perm(idx):
    # print(f"perm({idx}) start")
    # 1. 기저조건
    if idx == R: # 기저조건
        # 재귀호출 하지 않음
        print(res)
        return # 함수를 종료
    # 그 다음을 호출한다.

    # 2. 유도조건
    # 아직 뽑지 않은 숫자 중에서 숫자를 뽑고, 그 다음 숫자를 뽑으러 가야 함
    for i in range(N):
        if not visited[i]: # 5개 숫자 중에서 i번째를 뽑지 않았다면
            visited[i] = True # i번째 숫자를 뽑는다
            res[idx] = arr[i] # i번째 숫자를 idx번째
            perm(idx+1) # 그다음 자리 수 뽑으러 가기
            visited[i] = False # 방문처리 초기화

    # print(f"perm({idx}) end")
    

# N개의 원소 중에서
# 0, 1, .., R-1까지 뽑아야 함
perm(0) # 0번 위치 하나만 뽑고, perm(1) 호출
```

### 부분집합

```python
arr = [1, 2, 3, 4, 5]

# 부분집합
# - 각 원소를 포함할 것인가? 포함하지 않을 것인가?
# - 비트마스킹(0 or 1)

N = len(arr)
out = [False] * N # 출력배열(해당 위치 포함여부)

# 재귀함수 설계
# arr의 0번째 ~ N-1번째 수까지 각 수의 포함여부 결정하기..
# N개의 수를 한번에 모두 결정하지 않는다.
# 1개씩만 처리
# ex) 0번째만 포함여부 결정하고 1~N-1은 나중에 결정
# ex) 1번째만 결정하고         2~N-1은 나중에 결정..

def f(idx):
    # 기저조건
    if idx == N: # N-1까지는 결정할 원소가 있지만 N번 인덱스는 그런 원소 없음(리스트 범위 밖)
        # print(out)
        for i in range(N):
            if out[i]:
                print(arr[i], end=' ')
        print()
        return
    
    # 유도조건 (N-1)까지는 뽑을지 말지 결정 가능.
    out[idx] = True # idx번째 부분집합에 포함시키고
    f(idx+1) # idx+1번째 결정하러 가기
    out[idx] = False # idx번째를 포함시키지 말고
    f(idx+1) # idx+1번째 결정하러 가기

f(0) # 0번째 인덱스를 포함할지 말지 결정.
```

### 계산기2

```python
T = 10 # 테스트케이스 10개 고정

for tc in range(1, T+1):
    N = int(input()) # 문자열의 길이(중위표현식)
    exp = input() # 중위표현식
    out = '' # 후위표기식을 저장할 변수

    # exp = "9+5*2+1+3*3*7*6*9*1*7"

    # Step 1. 중위표기식 => 후위표기식으로 변환하기
    #  - 연산자의 우선순위를 정렬하는 것
    #  - 연산자의 스택을 사용

    # 규칙
    # exp를 왼쪽부터 오른쪽으로 가면서 한 문자(c)씩 검사
    # 1. c가 피연산자라면 => out에 그대로 출력(후위표기식에 이어붙임)
    # 2. c가 연산자라면
    #    2.1. 스택이 비어있다면 => c를 스택에 push
    #    2.2. 스택이 비어있지 않다면 => 스택의 top과 c를 비교
    #         2.2.1. top의 우선순위가 낮다면 => c를 스택에 push
    #         2.2.2. top의 우선순위 == c의 우선순위 => 먼저 스택에 들어있는 것이 더 우선 => top을 꺼내서 출력한 후, c를 push
    #         2.2.3. top의 우선순위가 더 높다면 => c보다 우선순위가 높거나 같은 것들을 전부 pop해서 출력 => c를 push
    # 3. 검사가 다 끝났으면, 마지막에는 스택을 비워준다.

    stack = [] # 연산자의 스택

    for c in exp: # 중위표기식에서 왼쪽부터 오른쪽으로 한 문자(c)씩 검사
        if c == '*': # 우선순위 높은 연산자
            if not stack: # 스택이 비어있다면
                stack.append(c)
            elif stack[-1] == '+': # 스택이 비어있지 않고, top이 '+'라면
                stack.append(c)
            else: # 우선순위 같은 경우
                while stack and stack[-1] == '*': # 스택에 있는 것을 먼저 꺼내서 출력
                    out += stack.pop() # 스택에 있는 것을 먼저 꺼내고
                stack.append(c) # 현재 c 그다음에 스택에 추가
        
        elif c == '+':
            while stack: # 스택에 뭔가가 있다면, 스택에 있는 것이 현재 연산자보다 우선순위가 높음
                out += stack.pop()
            stack.append(c)
        
        else: # 피연산자라면
            out += c
    
    # 검사가 끝나고 스택을 전부 비워준다.
    while stack:
        out += stack.pop()

    # Step 2. 후위표기식 계산하기
    # - 숫자의 스택 사용
    
    stack2 = [] # 숫자의 스택
    # 스택에서 가장 최근의 두개의 숫자를 꺼내서 계산한다음, 계산 결과를 다시 스택에 넣는다
    # 왼쪽 -> 오른쪽 순서로 한 문자씩 본다
    # 피연산자라면 => 스택에 넣는다.
    # 연산자라면 => 스택에서 두 개 꺼내서 계산한다음 다시 스택에 넣는다

    for c in out:
        if '0' <= c <= '9': # 만약에 문자 c가 숫자문자라면
            stack2.append(int(c)) # 숫자의 스택에 정수로 변환해서 push
        elif c == '+':
            num1 = stack2.pop()
            num2 = stack2.pop()
            stack2.append(num1+num2)
        elif c == '*':
            num1 = stack2.pop()
            num2 = stack2.pop()
            stack2.append(num1*num2)
    
    # 계산 후 스택에 마지막에 들어있는 숫자가 계산 결과
    print(f"#{tc} {stack2.pop()}")
```