# [0821] 알고리즘 11일차 - Queue1(2)

## 너비우선탐색 (BFS, Breadth First Search)

탐색 시작점의 인접한 정점들을 모두 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식

### DFS vs BFS

DFS 알고리즘

```python
visited : 방문처리 배열 (리스트)
stack : 인접 노드를 저장할 스택(갈림길에서 한개만 선택해서 탐색해 나감, 나머지는 스택에 저장해두고 나중에 가자.)

v: 시작점
1. 시작점을 방문처리 후 스택에 집어넣는다.
visited[v] = 1 
stack.push(v)

2. 스택이 완전히 빌 때까지 while문 반복(stack에 원소가 남아 있다면 while문 반복)
while stack:
		2.1. while문의 첫번째 문장에서 pop(그 다음 탐색할 노드 v)
		v = stack.pop()
		
		2.2. v를 기준으로 해서 인접 노드(w)를 탐색
		2.3. 인접 노드 중에 아직 방문하지 않은 노드가 있다면 stack에 집어넣는다
		for w (v의 인접노드들)
				if visited[w] == 0: # 아직 그 노드를 방문하지 않았다면
						visited[w] = 1 # 방문 처리 후에 
						stack.push(w) # 스택에 넣는다.

```

BFS 알고리즘

```python
visited : 방문처리 배열 (리스트)
queue : 인접 노드를 저장할 큐(마주치는 인접노드를 순서대로 방문하기 위해)

v: 시작점
1. 시작점을 방문처리 후 큐에 집어넣는다.
visited[v] = 1 
queue.enqueue(v)

2. 큐이 완전히 빌 때까지 while문 반복(큐에 원소가 남아 있다면 while문 반복)
while queue:
		2.1. while문의 첫번째 문장에서 dequeue(그 다음 탐색할 노드 v)
		v = queue.dequeue()
		
		2.2. v를 기준으로 해서 인접 노드(w)를 탐색
		2.3. 인접 노드 중에 아직 방문하지 않은 노드가 있다면 큐에 집어넣는다
		for w (v의 인접노드들)
				if visited[w] == 0: # 아직 그 노드를 방문하지 않았다면
						visited[w] = 1 # 방문 처리 후에 
						queue.enqueue(w) # 스택에 넣는다.

```