- 카운팅 정렬
- 완전 검색
- 탐욕 알고리즘

---

# 카운팅 정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식

- **정수**나 **정수로 표현할 수 있는 자료**에 대해서만 적용 가능
    - **각 항목의 발생 회수를 기록하기 위해**, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
- **즉, 누적합으로 정렬된 위치를 알 수 있음!**

- 카운팅 배열을 만들면 ⇒ 나보다 작은 것의 개수를 구할 수 있음
    - 누적합 배열을 만들면 나보다 작은 것의 개수를 바로(한번에) 구할 수 있음.
    - 누적합 배열 ⇒ 그 숫자의 정렬된 위치를 나타냄
    
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함.
- 시간 복잡도 O(n+k): n은 리스트 길이, k는 정수의 최댓값

### 카운팅 정렬 과정 예시

1단계: data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장한다.

2단계: 정렬된 집합에서 각 항목의 앞에  위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정한다.

3단계: data의 마지막 원소 1의 발생횟수 COUNTS[1]을 감소시키고 TEMP에 1을 삽입한다.

```python
def countint_sort(DATA, TEMP, k):
    COUNTS = [0] * (k + 1)

# DATA[] -- 입력배열(원소는 0이상 k이하 정수)  
# TEMP[] -- 정렬된 배열
# COUNTS[] -- 카운트 배열

    for i in range(len(DATA)): # DATA[i] 발생횟수 기록
		    COUNS[DATA[i]] += 1
		    
		for i in range(1, k + 1): # COUNTS 값 누적
				COUNTS[i] += COUNTS[i - 1]
				
		for i in range(len(DATA)-1, -1, -1):
				COUNTS[DATA[i]] -= 1
				TEMP[COUNTS[DATA[i]]] = DATA[i]
```

# 완전 검색

문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법. Brute-force/ generaate-and-test

### Baby-gin Game

6장의 카드가 run/triplet으로만 구성된 경우

순열로 만든 함수로 해결 가능(반  잘라서 검사)

# 탐욕 알고리즘

여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방식. 최적이라는 보장은 없음

1. 해 선택
2. 실행 가능성 검사
3. 해 검사

### 거스름돈 줄이기

### Baby-gin Game

```python
num = 456789 # BabyGin 확인할 6자리 수
c = [0] * 12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6):
		c[num % 10] += 1  # num % 10은 num 의 1의 자릿수
		num //= 10
```