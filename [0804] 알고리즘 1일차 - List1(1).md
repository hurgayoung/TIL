# [0804] 알고리즘 1일차 - List (1)

- 과정 소개
- 알고리즘
- 배열
- 연습 문제
- 버블 정렬
- 카운팅 정렬
- 완전 검색
- 탐욕 알고리즘

# 알고리즘

문제를 해결하기 위한 절차, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

알고리즘의 작업량은 ‘시간 복잡도’로 표현함

### 좋은 알고리즘이란?

정확성: 얼마나 정확하게 동작하는가

작업량:  얼마나 적은 연산으로 원하는 결과를 얻어내는가

메모리 사용량: 얼마나 적은 메모리를 사용하는가

단순성: 얼마나 단순한가

최적성: 더 이상 개선할 여지없이 최적화되었는가

# 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 사용 구조 

1차원 배열: 배열을 선언할 때는 프로그램에서 사용할 배열 이름이 필요합니다.

```python
arr = list()
arr = [ ]
arr = [0] * 10
arr = [1, 2, 3]
arr[0] = 10 # ‘배열 arr의 0번 원소에 10을 저장하라’
```

- 입력받은 정수를 1차원 배열에 저장하는 방법
    - 조건
        - 첫 줄에 양수의 개수 n
        - 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어집니다.
    - 코드
        
        ```python
        N= int(intput())
        arr = list(map(int, input(). split()))
        ```
        

- 배열 원소의 합 s 계산하기
    
    ```python
    s = 0
    for i in range(N):     # 배열의 모든 원소 꺼내기: for x in arr:
    	s += arr[i]           # s += x
    ```
    

- 배열 원소 중 최댓값 max_v 찾기
    
    ```python
    max_v = arr[0]            # 첫 원소를 최대로 가정
    for i in range(1, N):     # 배열의 모든 원소 꺼내기: for x in arr:
    	  if max_v  < arr[i]:
    	      max_v = arr [i]   # arr[i]가 더 크면 max_v 갱신
    ```
    
    ***최댓값이 여러 개인 경우? → 가장 왼쪽의 최댓값 인덱스**
    

- 배열 원소 중 최댓값의 **인덱스** max_idx 찾기
    
    ```python
    max_idx = 0                       # 첫 원소를 최대로 가정
    for i in range(1, N):     
    	  if arr[max_idx]  < arr[i]:    # 더 큰 값을 만나면
    	      max_idx = i               # max_idx 갱신
    ```
    

- 최댓값이 여러 개인 경우 마지막 인덱스 max_idx 찾기
    
    ```python
    max_idx = 0                        # 첫 원소를 최대로 가정
    for i in range(1, N):     
    	  if arr[max_idx]  <= arr[i]:    # 더 큰 값 또는 같은 값이면
    	      max_idx = i                # max_idx 갱신
    ```
    

- 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1을 idx에 넣기
    
    ```python
    # 인덱스 6개, 찾는 값 5
    # 2 7 5 3 1 7
    
    N, V = map(int,input().split()) # N, 찾는 값 V
    arr= list(map(int,input().split()))
    ```
    

- 배열 원소의 최댓값의 마지막 인덱스를 찾는 코드
    
    ```python
    idx = -1                        # 찾는 값이 없다고 가정
    for i in range(1, N):     
    	  if arr[i] == V :            # arr[i]가 찾는 값이면
    	      idx = i                 # 인덱스 저장
    	      break                   # for i
    ```
    

# 3. 버블 정렬

정렬이란, 2개 이상의 자료를 키(특정 기준)에 의해 오름차순 혹은 내림차순으로 재배열하는 알고리즘. 버블 정렬이란 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식.

오름차순 예시

가장 큰 숫자가 배열의 가장 오른쪽에 남도록!

```python
BubbleSort(a, N)                    # 정렬할 배열과 배열의 크기
		for i : N - 1 -> 1              # 정렬할 구간의 끝
				for j : 0 -> i - 1          # 비교할 원소 중 왼쪽 원소의 인덱스
						if a[j] > a[j + 1]      # 왼쪽 원소가 더 크면
								a[j] <-> a[j + 1]   # 오른쪽 원소와 교환
```

```python
BubbleSort(a, N)                    # 정렬할 List, N 원소 수
		for i in range(N - 1, 0 , -1)   # 정렬할 구간의 끝
				for j in range(i):          # 비교할 원소 중 왼쪽 원소 인덱스 j
						if a[j] > a[j + 1]:
								a[j] ,a[j + 1] = a[j + 1], a[j]   # 원소 교환
```