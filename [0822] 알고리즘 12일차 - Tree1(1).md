# [0822] 알고리즘 12일차 - Tree1(1)

# 1. 트리

## 1-1. 트리의 개념

- 비선형 구조, 계층 구조
- 원소들 간에 1(부모):n(자식) 관계를 가지는 자료구조
- 원소들 간에 계층관계를 가지는 계층형 자료구조
- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무) 모양의 구조 🌲

## 1-2. 트리의 정의

- 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
    - 노드 중 최상위 노드(부모)를 루트(root)라고 한다.
    - 나머지 노드들은 n(≥0)개의 분리 집합 T1, …, TN으로 분리될 수 있다.
- 재귀적인 성격을 갖는다.
    - 나머지 노드들 T1, …, TN은 각각 하나의 트리가 되며 루트의 부 트리(subtree)라 한다.
    - subtree에서 자식은 루트 노드가 되는 것이다.

![image.png](attachment:5d304c36-09f5-4de4-808d-c10596c4a6f4:image.png)

## 1-3. 용어 정리

![트리의 예시](attachment:d22bfa26-1823-4759-a1f0-71e8da1ea325:image.png)

트리의 예시

- **노드(node)** - 트리의 원소
    - 트리 T의 노드 - A, B, C, D, E, F, G, H, I, J, K
- **간선(edge)** - 노드를 연결하는 선, 부모 모드와 자식 노드를 연결
- **루트 노드 (root node)** - 트리의 시작 노드, 최상위 부모
    - 트리 T의 루트노드
- **형제 노드 (sibling node)** - 같은 부모를 공유하는 자식 노드들
    - B, C, D는 형제 노드
- **조상 노드** - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
    - K의 조상 노드: F, B, A
- **서브 트리 (subtree)** - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- **자손 노드** - 서브 트리에 있는 하위 레벨의 노드들
    - B의 자손 노드: E, F, K

> 노드의 차수
> 
- 노드에 연결된 자식 노드의 ‘개수’
    - B의 차수 = 2, C의 차수 = 1

> 트리의 차수
> 
- 트리에 있는 노드의 차수 중에서 가장 큰 ‘값’
    - 트리 T의 차수 = 3

> 단말 노드(리프 노드)
> 
- 차수가 0인 노드. 자식 노드가 없는 노드.
    - E, K, G, H, I, J 가 해당됨

![image.png](attachment:d9e522fe-474f-4aae-8d96-14bf2563e5d5:image.png)

> 노드의 높이
> 
- 루트에서 노드에 이르는 간선의 수. 노드의 레벨.
    - B의 높이 = 1, F의 높이 = 2

> 트리의 높이
> 
- 트리에 있는 노드의 높이 중에서 가장 큰 값. “최대” 레벨.
    - 트리 T의 높이 = 3

*차수와 높이의 차이에 대해 이해할 것!

# 2. 이진 트리

## 2-1. 이진 트리의 개념

- 모든 노드들이 “2개”의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리
    - 왼쪽 자식 노드 (left child node)
    - 오른쪽 자식 노드 (right child node)

![image.png](attachment:85ec3ebc-ec11-4f43-8557-8e5f004d1437:image.png)

## 2-2. 이진 트리의 특성

- 레벨 i에서의 노드의 최대 개수는 2^i개
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h+1)개가 되며, 최대 개수는 (2^h+1)-1개

![image.png](attachment:312979c2-b1ef-4794-8272-73b6cdd4850c:image.png)

## 2-3. 포화 이진 트리 (Full Binary Tree)

![image.png](attachment:5d79cef0-59d4-41e5-9eea-ac4924ba7853:image.png)

- 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
- 높이가 h일 때, 최대의 노드 개수인 (2^h+1)-1의 노드를 가진 이진 트리

- 루트를 1번으로 하여 정해진 위치에 대한 노드 번호를 가짐

## 2-4. 완전 이진 트리 (Complete Binary Tree)

![노드가 10개인 완전 이진 트리](attachment:38b13a14-362b-483c-bf08-3a13cbd7af42:image.png)

노드가 10개인 완전 이진 트리

- 높이가 h이고 노드 수가 n개일 때, “포화 이진 트리”의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 위에서부터 아래로, 왼쪽에서부터 오른쪽으로 빠짐없이 채워나가는 트리
- 포화, 완전, 편향 이진 트리 중에서 완전 이진 트리가  제일 중요하니 잘 알아두어야 한다고 하셨음 🌟
    - 완전 이진 트리는 배열로 나타낼 수 있기 때문!

## 2-5. 편향 이진 트리 (Skewed Binary Tree)

![image.png](attachment:ef99ccfd-8d66-43ce-ae91-294d8a00b929:image.png)

- 높이가 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
    - 왼쪽 편향, 오른쪽 편향

# 3. 순회

## 3-1. 순회의 개념

- 트리 수업에서 가장 중요한 개념! 🌟
- 트리는 비선형이라 선형구조처럼 선후 연결관계를 알 수 없다.
- 순회란 트리의 각 노드를 중복되지 않게 전부 방문하는 것이다.
    - 방문처리로 print를 했다는 뜻
- 기본적으로는 DFS 순회(재귀호출을 이용하기 때문) → 뒤에 나오는 3가지 방법
- 현재 탐색 중인 루트 노드를 기점으로 해서 순회 시작
    - 왼쪽 자식을 루트 노드로 해서 재귀 호출(L)
    - 오른쪽 자식을 루트 노드로 해서 재귀 호출(R)
    
    → 현재 탐색 중인 루트 노드를 언제 print(방문)할 것인가?
    

## 3-2. 순회 방법

![image.png](attachment:cf632d87-c758-49ee-91af-f76654f0a4df:image.png)

<aside>

1. 전위 순회 (preorder traversal) : VLR

부모 노드 방문 후, 자식 노드를 좌, 우 순서로 방문합니다.

</aside>

<aside>

1. 중위 순회 (inorder traversal) : LVR

왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순으로 방문합니다.

</aside>

<aside>

1. 후위 순회 (postorder traversal) : LRV

자식 노드를 좌, 우 순서로 방문한 후, 부모 노드로 방문합니다.

</aside>

*부모 노드 V 위치에 따라 달라진다고 볼 수 있음

## 3-3. 전위 순회

- 수행 방법

1️⃣ 현재 노드 n을 방문하여 처리한다. → V

2️⃣ 현재 노드 n의 왼쪽 서브트리로 이동한다. → L

3️⃣ 현재 노드 n의 오른쪽 서브트리로 이동한다. → R

- 알고리즘

```python
def preorder_traverse(T): #전위순회
		if T:                 # T is not None
				visit (T)         # print(T.item)
				preorder_traverse(T.left)
				preorder_traverse(T.right)
```

![image.png](attachment:d838fe2b-9837-40a9-8404-d13e562aa1ee:image.png)

## 3-4. 중위 순회

- 수행 방법

1️⃣ 현재 노드 n의 왼쪽 서브트리로 이동한다. → L

2️⃣ 현재 노드 n을 방문하여 처리한다. → V

3️⃣ 현재 노드 n의 오른쪽 서브트리로 이동한다. → R

- 알고리즘

```python
def inorder_traverse(T):  #중위순회
		if T:                 # T is not None
				inorder_traverse(T.left)
			  visit (T)         # print(T.item)
				inorder_traverse(T.right)
```

![image.png](attachment:68a4e18e-a847-4ade-9805-938158555df7:image.png)

## 3-5. 후위 순회

- 수행 방법

1️⃣ 현재 노드 n의 왼쪽 서브트리로 이동한다. → L

2️⃣ 현재 노드 n의 오른쪽 서브트리로 이동한다. → R

3️⃣ 현재 노드 n을 방문하여 처리한다. → V

- 알고리즘

```python
def postorder_traverse(T):  #후위순회
		if T:                   # T is not None
			postorder_traverse(T.left)
			postorder_traverse(T.right)
			visit (T)            # print(T.item)
```

![image.png](attachment:80b2bf3f-40aa-42aa-8165-419aa66ab9b6:image.png)

# 4. 이진 트리의 표현 (1)

![image.png](attachment:c0336d69-4ad5-4471-95f6-32dde69243fd:image.png)

- 배열을 이용한 이진 트리의 표현
- 이진 트리에 각 노드 번호를 다음과 같이 부여: 루트의 번호를 1로 하여 레벨 n에 있는 노드에 대해 왼쪽부터 오른쪽으로 2^n부터 (2^n+1)-1까지 번호를 차례로 부여

- 완전 이진 트리의 배열 표현
    - 0번 인덱스는 사용하지 않음
    - 루트 노드: 1번(1번 인덱스부터 사용)
    - 부모 인덱스가 i라면 왼쪽 자식 노드의 인덱스는 2*i, 오른쪽 자식 노드의 인덱스는 2*i+1
    - 자식 노드의 인덱스가 i라면 부모 노드의 인덱스는 i//2

### 노드 번호의 성질

![image.png](attachment:4d496e59-cbb5-443e-b107-6a04f74f1735:image.png)

🌟가장 중요한 포인트는 노드 번호가 i일 때 왼쪽/오른쪽 자식 노드 번호 구하기! (왼쪽은 2*i, 오른쪽은 2*i+1)

![image.png](attachment:31c2e39c-34dc-4f9a-9e6c-4125da244ddf:image.png)

# 5. 이진 트리의 표현 (2)

### 부모 번호를 인덱스로 자식 번호를 저장

![image.png](attachment:1fe491cd-818c-4cd5-a710-96fe4239ba9a:image.png)

```python
for i : 1 -> N
				read p, c
				if c1[p] == 0
								c1[p] = c
				else
								c2[p] = c
```

### 자식 번호를 인덱스로 부모 번호를 저장

![image.png](attachment:1b6506da-7912-4271-9acd-fd51471e8990:image.png)

```python
for i : 1 -> N
				read p, c
				par[c] = p
```

- 활용 예시 - 루트 찾기, 조상 찾기

![image.png](attachment:441c6e45-bb5e-4696-ba44-083a8f4cfa46:image.png)

```python
# 5번 노드의 조상 찾기
c = 5
while(a[c] != 0)       # 루트인지 확인
			 c = a[c]
			 
			 anc.append(c)   # 조상 목록
root = c
```

![image.png](attachment:72c2494a-e33d-4267-972d-157bcb22a70c:image.png)

![image.png](attachment:00e2ffb6-160a-46b2-b434-cdbca5d0b81d:image.png)

![image.png](attachment:178f7f39-af70-480e-b7ab-c26c1539f937:image.png)

![image.png](attachment:5085aff5-7529-4a1b-8e63-88f48e11751e:image.png)

### 연습문제

![image.png](attachment:623bc457-7fa8-4b9a-a472-57319939f2d8:image.png)

[강사님 풀이]

![image.png](attachment:485fcae9-87a2-4cd8-bdff-a792f5032041:image.png)

- 이진 트리 O, 완전 이진 트리 X

```python
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
```

⇒ 주어진 입력은 간선 리스트

```python
자식 노드를 리스트로 저장한다면?

1: [2, 3]
2: [4]
3: [5, 6]
4: [7]
5: [8, 9]
6: [10, 11]
7: [12]
8: []
9: []
10: []
11: [13]
12: []
13: []

# 교재의 이진트리표현2
              1  2  3  4  5  6  7   8  9  10  11  12  13
left_child  [ 2  4  5  7  8  10 12  -  -  -   13   -   -]
right_child [ 3  -  6  -  9  11  -  -  -  -   -    -   -]
```

```python
# 강사님 풀이코드

V = int(input()) # 정점의 개수, 정점번호는 1번부터 V번까지
arr = list(map(int, input().split()))

lft_child = [0] * (V+1) # 1 ~ V까지 인덱스가 필요하므로
rgt_child = [0] * (V+1)

for i in range(V-1):
    parent, child = arr[2*i], arr[2*i + 1]
    print(parent, child)
    if lft_child[parent] == 0:
        lft_child[parent] = child
    else:
        rgt_child[parent] = child

print(lft_child)
print(rgt_child)
# 트리 저장 완료

def f(root):
    # root : 현재 탐색하고 있는 트리의 루트 노드
    print(root, end=' ')
    # 유도 조건
    # 자식이 있다면, 해당 자식을 중심으로 순회
    if lft_child[root] != 0: # 왼쪽 자식이 있다면
        f(lft_child[root])
    if rgt_child[root] != 0: # 오른쪽 자식이 있다면
        f(rgt_child[root])

# 중위순회
def inorder(root):
    # root : 현재 탐색하고 있는 트리의 루트 노드
    
    # 유도 조건
    # 자식이 있다면, 해당 자식을 중심으로 순회
    if lft_child[root] != 0: # 왼쪽 자식이 있다면
        inorder(lft_child[root])

    print(root, end=' ')

    if rgt_child[root] != 0: # 오른쪽 자식이 있다면
        inorder(rgt_child[root])

# 후위순회
def postorder(root):
    # root : 현재 탐색하고 있는 트리의 루트 노드
    
    # 유도 조건
    # 자식이 있다면, 해당 자식을 중심으로 순회
    if lft_child[root] != 0: # 왼쪽 자식이 있다면
        postorder(lft_child[root])

    if rgt_child[root] != 0: # 오른쪽 자식이 있다면
        postorder(rgt_child[root])    

    print(root, end=' ')

# 트리의 순회
# 재귀함수의 설계
print("트리 전위순회 시작")
f(1) # 1번 노드를 중심으로 순회
print()
print("트리 전위순회 끝")

print("트리 중위순회 시작")
inorder(1) # 1번 노드를 중심으로 순회
print()
print("트리 중위순회 끝")

print("트리 후위순회 시작")
postorder(1) # 1번 노드를 중심으로 순회
print()
print("트리 후위순회 끝")
```