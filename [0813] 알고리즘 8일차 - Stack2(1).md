# [0813] 알고리즘 8일차 - Stack1(2)


# Function Call

- 시스템 스택
    - 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 저장
    - 함수 호출이 발생하면 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입

- 시스템 스택을 이용한 함수 호출과 복귀

![image.png](attachment:2866f371-cc2f-400e-a719-2a18e664dc11:image.png)

## 재귀 호출

함수가 자신과 같은 작업을 반복해야 할 때, 자신을 다시 호출하는 구조

### n에 대한 factorial

- 1부터 n까지의 모든 자연수를 곱하여 구하는 연산
    - 마지막에 구한 하위 값을 이용하여 상위 값을 구하는 작업을 반복

```python
n! = n x (n-1)!
	(n-1)! = (n-1) x (n-2)!
	(n-2)! = (n-2) x (n-3)!
	...
	2! = 2 x 1!
	1! = 1
```

![image.png](attachment:83a3f612-4b6c-4258-bb0b-4c16d002e532:image.png)

## 피보나치 수열

- 0과 1로 시작하고 이전의 두 수의 합을 다음 항으로 하는 수열
- 피보나치 수열의 i번째 항을 반환하는 함수를 재귀함수로 구현 가능

```python
def fibo(n):
		if n < 2:
				return n
		else:
				return fibo(n-1) + fibo(n-2)
```

## 재귀함수의 기본형

- 현재 호출 단계와 목표 단계를 인자로 사용
- 현재 단계 i, 목표 N을 인자로 갖는 재귀함수 f(i, N)가 기본형입니다.

```python
def f(i, N):
		if i == N:
				return
			elsek:
			f(i+1, N)
```

## 재귀 알고리즘 최적화: 메모이제이션

- 동적 계획법의 핵심이 되는 기술
- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술

```python
# memo를 위한 배열을 할당하고, 모두 0으로 초기화 한다.
# memo[0]을 0으로 memo[1]는 1로 초기화 한다.

def fibo1(n):
		if n >= 2 and memo[n] == 0:
				memo[n] = fibo1(n-1) + fibo1(n-2)
		return memo[n]
		
memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```

## 동적계획법 (DP, Dynamic Programming)

- 최적화를 위한 알고리즘
- 입력 크기가 작은 부분 문제들을 먼저 해결한 뒤, 그 결과를 바탕으로 더 큰 부분 문제를 순차적으로 해결해 나가며 최종적으로 전체 문제의 해답을 도출하는 알고리즘

```python
def fibo2(n):
		f = [0] * (n+1)
		f[0] = 0
		f[1] = 1
		for i in range(2, n+1):
			f[i] = f[i-1] + f[i-2]
			
		return f[n]
```

## 깊이 우선 탐색 (DFS, Depth First Search)

- 한 방향으로 가능한 한 깊게  탐색한 후, 더 이상 갈 곳이 없으면 되돌아와 다른 방향을 탐색
- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요:
    - **깊이 우선 탐색 (Depth First Search) ✅**
    - 너비 우선 탐색 (Breadth First Search)

- 동작 원리: 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

```python
visited[], stack[] 초기화
DFS(v)
		시작점 v 방문;
		vistited[v] <- true;
		while {
				if ( v의 인접 정점 중 방문 안 한 정점 w가 있으면)
						push(v);
							v <- w; (w에 방문)
				visited[w] <- true;
				else
							if (스택이 비어 있지 않으면)
									v <- pop(stack);
							else
									break		
		}
end DFS()					
```